# 저장소 설명
인프런 `김영한의 실전 자바 - 고급 1편, 멀티스레드와 동시성` 강의 메모 및 실습 저장소

# 강의 메모
## 프로세스와 스레드
멀티태스킹
- 하나의 컴퓨터 시스템이 여러 작업을 동시에 실행
- 스케쥴링: CPU에 어떤 프로그램을 얼마나 실행할지 운영체제가 결정하는 것

멀티프로세싱
- 멀티프로세서, CPU. H/W 관점.
- CPU core가 둘이상이면 싱글 core 보다 빠르게 실행된다. 

프로세스
- 실행중인 프로그램의 인스턴스.
- 프로세스마다 독립적인 메모리 공간을 가진다.
- 하나 이상의 스레드를 포함한다. 

스레드
- 프로세스 내에서 작업 단위.
- 프로세스보다 가볍다. 
- 하나의 프로세스 내에서 스레드 들은 힙, 코드 메모리 공간을 공유한다. 스택 메모리는 개별적으로 가진다. 
- CPU를 사용해서 Code를 하나씩 실행한다. 

스케쥴링
- 스케쥴링 큐를 가지고 있다. 큐에는 각 스레드가 들어간다. ㅇ
- 큐에있는 스레드 정보를 CPU가 순서대로 불러와서 사용하고, 다시 큐에 넣는다. 
- Core가 늘어날 수록 병렬 처리가 된다. 

컨텍스트 스위칭
- 스레드가 변경되는 시점에 기존에 실행되는 스레드의 정보를 메모리에 저장하고, 새로 실행할 스레드의 정보를 CPU로 불러온다. 
- 이러한 작업은 CPU 입장에서는 어느정도 시간을 쓰는 작업이다.

## 스레드
스레드 정보
1. threadId: 스레드의 고유한 아이디
2. threadName: 스레드의 이름. 고유하지는 않다. 
3. priority: 스레드의 우선 순위. 기본 값 5. 1이 제일 낮고, 10이 제일 높다. 
4. threadGroup: 스레드 그룹
5. state: 스레드의 상태
   - NEW (새로운 상태)
      - 신규 생성되었고 아직 사용되지 않음
   - RUNNABLE (실행 가능 상태)
      - 스레드가 실행 중이거나 실행될 준비가 된 상태
   - 일시 중지 상태(Suspended State)
      - BLOCKED (차단 상태)
         - 스레드가 동기화 락을 기다리는 상태
         - 예: synchronized
      - WAITING (대기 상태)
         - 스레드가 다른 스레의 특정 작업이 완료되기를 기다리는 상태
         - 예: 파일 전송
      - TIMED_WAITING (시간 제한 대기) 
         - 일정 시간 동안 기다리는 상태
         - 예: Thread.sleep()
   - TERMINATED (종료 상태)
      - 스레드가 실행을 마친 상태. 

인터럽트
- waiting 상태의 스레드를 인터럽트를 통해서 깨울 수 있다. 깨워진 스레드는 runnable 상태가 된다. 
- `interrupt()` 메서드로 호출 할 수 있다. 
- `interrupt()` 가 호출되면 `isInterrupted` 상태가 `true`가 되는데, 별도의 처리가 없으면 이 상태가 계속 유지된다. 
   - 이후애 interruptException을 발생시키는 메서드(예: sleep)를 만나면 예외가 발생한다. 
- 대안으로 `interrupted()` 메서드를 호출하면, 상태가 인터럽트일 경우에 상태를 `false`로 변경해준다. 

yield
- sleep을 사용하면 thread가 runnable -> timed_waiting 상태로 변경이 발생한다. 
- yield를 사용하면 runnable 상태를 유지하면서, 스케쥴링 큐에 다시 대기하도록 할 수 있다. 
- 잠깐 실행을 양보할 때에는 yield를 사용해서 처리할 수 있다. 일정 시간 양보하려면 sleep을 사용한다. 

## 메모리 가시성
메모리 가시성
- 멀티스레드에서 Cache에서 읽어오는 데이터에 의해서 각 스레드 사이에 데이터 동기화가 바로 안되는 문제

메모리 동기화
- Thread의 변경은 cache에 반영되는데 
- cache의 변경 내용이 main memory에 반영되는 시점은 알 수 없다
- 그리고 다른 thread에서 바라보는 cache에 main memory의 변경 사항이 반영되는 시점도 알 수 없다. 
- 이로 인해서 각 스레드간에 참조하는 변수 값의 차이가 발생하는 것을 메모리 가시성 문제라고 한다. 
- 보통 context switching이 발생할 때, 스레드의 작업을 백업해야하기 때문에 이때 main memory에 반영될 가능성이 높다. 

Volatile
- main memory를 항상 사용한다. 
- cache 보다는 느리다는 문제가 있지만, 가시성 문제를 피할 수 있다. 

Java Memory Model
- happens-before
   - 스레드간 작업 순서에 대한 내용
   - A작업이 B작업보다 happens-before 관계에 있다면, A 작업의 변경 사항은 B 작업에서 볼 수 있다. 

## 동기화 - synchronized
임계 영역 (Critical Section)
- 여러 스레드가 동시에 접근하면 데이터의 불일치나 예상하지 못한 동작이 발생할 수 있는 코드 부분
- 예: 여러 스레드가 공유자원 수정

synchronized
- 임계 영역 문제를 해결하기 위한 문법
- monitor lock: 자바에서 각각의 객체는 lock을 가진다. 이 Lock을 획득하는 스레드가 임계 영역에서의 코드를 먼저 처리할 수 있고, 나머지 스레드는 대기하게 된다. 
- 다른 스레드가 lock을 가지고 있으면, 접근하는 스레드의 상태는 Runnable -> Blocked로 변경된다. 
- synchroized는 기본적으로 메서드에 설정하지만, 그 범위를 줄이기 위해서 메서드 내부에도 정의할 수 있다. 
- 장점
   - 프로그래밍 언어로 잠금
   - 자동 잠금 해제
- 단점
   - 무한대기: 스레드의 락이 풀릴 때까지 무한 대기 한다. 타임아웃이나 인터럽트가 없다. 